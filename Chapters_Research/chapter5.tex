\chapter{Evaluation}

In my project I have shown that the performance of ACO can be improved through the use of a clustering algorithm and gone some way to find what that clustering algorithm should be. I have also shown the poor performance of clustering algorithms on complex VLSI data and how 2-opt can help improve upon tours and how the clustering algorithms all return data in a similar structure which allows 2-opt to find similar tours amongst all clustering algorithms.

\section{Process}

I adopted a version of Scrum I followed it reasonably closely and the use of Jira definitely helped. I found weekly sprints to be a really good way of planning my next week, however sometimes I didn't follow them all that closely or I let the sprints take slightly longer than a week. I could have followed this process more closer. 

I implemented all the requirements that were needed to run my tests and there was only one feature that I would have liked to implement but ran out of time to do so. This was an improved clustering algorithm. This was always an extension feature but if I had focused more on it and given it a higher priority then I might have been able to do it. 

\section{Implementation}

I'm happy with my code and my implementation I feel that I made a good choice using Python even though it's quite a slow language to run it is easy to write and comes with lots of useful features and libraries which sped up the implementation phase of my project.

The run time of the experiments was a big problem and if I had chosen C++ then this would have been less of an issue. C++ is a much faster language and would have allowed me to run more experiments and investigate more questions.

The code was quite inefficient in places there are areas that would really benefit from multi threading such as ACO and 2-OPT. I did implement a second ACO library that used multi threading but I never used it in any tests because it generated tours which were worse than those generated by ACOPY.

\subsection{Testing}
 
There was not very much testing, I did make up for this with my own manual testing but this was not controlled; there was no test table I just ran through the program and ensured it worked, but there was no procedure for how to do this. I should have implemented more unit tests that covered everything in the project. I did unit test some areas but I felt that unit testing the entire project would be too complex and take too a long time, maybe this is true but it would have given me more confidence in my code and allow for errors in my code to be spotted more quickly.

\section{Experiments}

I'm mostly pleased with the results I achieved in my experiments however there were a few problems.

I didn't anticipate how long these experiments would take to run especially for the larger problems. It ended up taking 345 hours to run all the tests which was much longer than I had planned. Most of this time was spent running the larger problems and I could have saved a considerable amount of time if I had chosen smaller sized problems.

I also didn't want to use my computer when I was running these tests in case my use negatively impacted the run time of the algorithms so I couldn't do work on my report. If I had access to another computer then I could have left my computer running these tests and worked on my report, due to the current circumstances and not being able to use any University facilities this was not possible.

The experiment looking into ACO parameters didn't show any significant results, if I had varied more parameters at one time then this would not have been a problem. I didn't have time to do this in my project especially towards the end, if I had spent less time running tests on larger problem files then I might have had time to run more experiments and could have potentially answered this question more thoroughly.

I could have been more efficient with my experiments and carried them out in a more automated way. When I ran the experiments I had to then then had to go through the log files to extract the run time and distance information. This slowed down the process and was a very tedious task. I also did the 2-opt runs separate to the non 2-opt runs which slowed me down and duplicated a lot of the work I had to do, what I should have done instead, is have those run once and then record the time taken and tour lengths before and after 2-opt.

\section{Future Work}

This project is very broad and covers lots of areas of Computer Science, this means that there were features I would have liked to implement and experiments I would have liked to run but couldn't due to the short nature of this project.

It would have been interesting to look at what the optimal K-Means value is for a piece of data. As I have shown K-Means is sometimes the best performing clustering algorithm however it needs a k value so it knows how many clusters to create in the data. This k value may be related to the size of the data, if several k values were chosen for several pieces of data then a pattern may emerge and you may be able to show what the optimal.

There are other clustering algorithms that I didn't experiment with, it may be possible that one of these performs better with TSP data or one of these is better suited to VLSI data. My experiments showed that VLSI data is very tricky to cluster and all the algorithms that I have implemented do quite a poor job. There may be an already created clustering algorithm that performs really well on this type of data.

The experiment where I tested optimal ACO values didn't yield any significant results. This was down to the tests only changing one parameter at a time and ACO is dependent on many parameters it would be nice to re-do this experiment and change many parameters at one time, this would take a long time to run and would be thousands of ACO runs.

One of the things I wanted to do but didn't have enough time for was to create a new clustering algorithm that expands to fit the complex data present in TSPs. This would be similar to the algorithm developed in \cite{pang_chao-yang_ben-qiong_zhang_jie_wei_shan_zheng-chao_2014}, it would map out the expansions of data and then cluster to fit those expansions. This should result in shorter tours that are found quicker but required a lot of work that I didn't have time for.

There are versions of 2-opt that swap more nodes and might find higher quality tours. 2.5-opt and 3-opt it would be interesting to see their effects on the tours and see how much they can improve it. Although there still only perform local searches so the improvements they can make are limited and they are unlikely to find the globally optimal solution. 

I implemented a greedy nearest neighbours search algorithm to calculate the tours in every cluster, however I never used this in my experiments. It would be interesting to compare this against ACO for in cluster tour generation.

I implemented the BIRCH clustering algorithm but never used it in any tests because you need to choose several parameters. In the future the impact of BIRCH on TSPs could be explored, BIRCH performs well with lots of nodes so could potentially improve the tours of the large TSPs. 

\section{What I Would Do Differently}

If I was to redo this project I would give myself longer to run the experiments as this was in my opinion the biggest failure in my project. If I had started running experiments earlier or had access to more computers then this would not of been a big problem. I would also run the experiments on smaller problems instead of choosing 100, 200 and 300 node problems I should have chosen 100, 150 and 200 node problems, the larger problems took too long to run and could have benefited from the ACO being run for more iterations.

I would have also spent more time focusing on the better clustering algorithm, this is a feature that would result in a big improvement in tours and a reduction in run time. I would focus a much greater proportion of time on this feature.
